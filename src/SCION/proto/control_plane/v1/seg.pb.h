// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/control_plane/v1/seg.proto
// Protobuf C++ Version: 4.24.0-main

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "proto/control_plane/v1/seg_extensions.pb.h"
#include "proto/crypto/v1/signed.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
namespace proto {
namespace control_plane {
namespace v1 {
class ASEntry;
struct ASEntryDefaultTypeInternal;
extern ASEntryDefaultTypeInternal _ASEntry_default_instance_;
class ASEntrySignedBody;
struct ASEntrySignedBodyDefaultTypeInternal;
extern ASEntrySignedBodyDefaultTypeInternal _ASEntrySignedBody_default_instance_;
class BeaconRequest;
struct BeaconRequestDefaultTypeInternal;
extern BeaconRequestDefaultTypeInternal _BeaconRequest_default_instance_;
class BeaconResponse;
struct BeaconResponseDefaultTypeInternal;
extern BeaconResponseDefaultTypeInternal _BeaconResponse_default_instance_;
class HopEntry;
struct HopEntryDefaultTypeInternal;
extern HopEntryDefaultTypeInternal _HopEntry_default_instance_;
class HopField;
struct HopFieldDefaultTypeInternal;
extern HopFieldDefaultTypeInternal _HopField_default_instance_;
class PathSegment;
struct PathSegmentDefaultTypeInternal;
extern PathSegmentDefaultTypeInternal _PathSegment_default_instance_;
class PeerEntry;
struct PeerEntryDefaultTypeInternal;
extern PeerEntryDefaultTypeInternal _PeerEntry_default_instance_;
class SegmentInformation;
struct SegmentInformationDefaultTypeInternal;
extern SegmentInformationDefaultTypeInternal _SegmentInformation_default_instance_;
class SegmentsRegistrationRequest;
struct SegmentsRegistrationRequestDefaultTypeInternal;
extern SegmentsRegistrationRequestDefaultTypeInternal _SegmentsRegistrationRequest_default_instance_;
class SegmentsRegistrationRequest_Segments;
struct SegmentsRegistrationRequest_SegmentsDefaultTypeInternal;
extern SegmentsRegistrationRequest_SegmentsDefaultTypeInternal _SegmentsRegistrationRequest_Segments_default_instance_;
class SegmentsRegistrationRequest_SegmentsEntry_DoNotUse;
struct SegmentsRegistrationRequest_SegmentsEntry_DoNotUseDefaultTypeInternal;
extern SegmentsRegistrationRequest_SegmentsEntry_DoNotUseDefaultTypeInternal _SegmentsRegistrationRequest_SegmentsEntry_DoNotUse_default_instance_;
class SegmentsRegistrationResponse;
struct SegmentsRegistrationResponseDefaultTypeInternal;
extern SegmentsRegistrationResponseDefaultTypeInternal _SegmentsRegistrationResponse_default_instance_;
class SegmentsRequest;
struct SegmentsRequestDefaultTypeInternal;
extern SegmentsRequestDefaultTypeInternal _SegmentsRequest_default_instance_;
class SegmentsResponse;
struct SegmentsResponseDefaultTypeInternal;
extern SegmentsResponseDefaultTypeInternal _SegmentsResponse_default_instance_;
class SegmentsResponse_Segments;
struct SegmentsResponse_SegmentsDefaultTypeInternal;
extern SegmentsResponse_SegmentsDefaultTypeInternal _SegmentsResponse_Segments_default_instance_;
class SegmentsResponse_SegmentsEntry_DoNotUse;
struct SegmentsResponse_SegmentsEntry_DoNotUseDefaultTypeInternal;
extern SegmentsResponse_SegmentsEntry_DoNotUseDefaultTypeInternal _SegmentsResponse_SegmentsEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace control_plane
}  // namespace proto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace proto {
namespace control_plane {
namespace v1 {
enum SegmentType : int {
  SEGMENT_TYPE_UNSPECIFIED = 0,
  SEGMENT_TYPE_UP = 1,
  SEGMENT_TYPE_DOWN = 2,
  SEGMENT_TYPE_CORE = 3,
  SegmentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SegmentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SegmentType_IsValid(int value);
extern const uint32_t SegmentType_internal_data_[];
constexpr SegmentType SegmentType_MIN = static_cast<SegmentType>(0);
constexpr SegmentType SegmentType_MAX = static_cast<SegmentType>(3);
constexpr int SegmentType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SegmentType_descriptor();
template <typename T>
const std::string& SegmentType_Name(T value) {
  static_assert(std::is_same<T, SegmentType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SegmentType_Name().");
  return SegmentType_Name(static_cast<SegmentType>(value));
}
template <>
inline const std::string& SegmentType_Name(SegmentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SegmentType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SegmentType_Parse(absl::string_view name, SegmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SegmentType>(
      SegmentType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SegmentsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.SegmentsRequest) */ {
 public:
  inline SegmentsRequest() : SegmentsRequest(nullptr) {}
  ~SegmentsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsRequest(::google::protobuf::internal::ConstantInitialized);

  inline SegmentsRequest(const SegmentsRequest& from)
      : SegmentsRequest(nullptr, from) {}
  SegmentsRequest(SegmentsRequest&& from) noexcept
    : SegmentsRequest() {
    *this = ::std::move(from);
  }

  inline SegmentsRequest& operator=(const SegmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsRequest& operator=(SegmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentsRequest* internal_default_instance() {
    return reinterpret_cast<const SegmentsRequest*>(
               &_SegmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SegmentsRequest& a, SegmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SegmentsRequest& from) {
    SegmentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SegmentsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.SegmentsRequest";
  }
  protected:
  explicit SegmentsRequest(::google::protobuf::Arena* arena);
  SegmentsRequest(::google::protobuf::Arena* arena, const SegmentsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcIsdAsFieldNumber = 1,
    kDstIsdAsFieldNumber = 2,
  };
  // uint64 src_isd_as = 1;
  void clear_src_isd_as() ;
  ::uint64_t src_isd_as() const;
  void set_src_isd_as(::uint64_t value);

  private:
  ::uint64_t _internal_src_isd_as() const;
  void _internal_set_src_isd_as(::uint64_t value);

  public:
  // uint64 dst_isd_as = 2;
  void clear_dst_isd_as() ;
  ::uint64_t dst_isd_as() const;
  void set_dst_isd_as(::uint64_t value);

  private:
  ::uint64_t _internal_dst_isd_as() const;
  void _internal_set_dst_isd_as(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.SegmentsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t src_isd_as_;
    ::uint64_t dst_isd_as_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class SegmentsRegistrationResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.SegmentsRegistrationResponse) */ {
 public:
  inline SegmentsRegistrationResponse() : SegmentsRegistrationResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsRegistrationResponse(::google::protobuf::internal::ConstantInitialized);

  inline SegmentsRegistrationResponse(const SegmentsRegistrationResponse& from)
      : SegmentsRegistrationResponse(nullptr, from) {}
  SegmentsRegistrationResponse(SegmentsRegistrationResponse&& from) noexcept
    : SegmentsRegistrationResponse() {
    *this = ::std::move(from);
  }

  inline SegmentsRegistrationResponse& operator=(const SegmentsRegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsRegistrationResponse& operator=(SegmentsRegistrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsRegistrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentsRegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const SegmentsRegistrationResponse*>(
               &_SegmentsRegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SegmentsRegistrationResponse& a, SegmentsRegistrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentsRegistrationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsRegistrationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsRegistrationResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentsRegistrationResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SegmentsRegistrationResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SegmentsRegistrationResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.SegmentsRegistrationResponse";
  }
  protected:
  explicit SegmentsRegistrationResponse(::google::protobuf::Arena* arena);
  SegmentsRegistrationResponse(::google::protobuf::Arena* arena, const SegmentsRegistrationResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.SegmentsRegistrationResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class SegmentInformation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.SegmentInformation) */ {
 public:
  inline SegmentInformation() : SegmentInformation(nullptr) {}
  ~SegmentInformation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentInformation(::google::protobuf::internal::ConstantInitialized);

  inline SegmentInformation(const SegmentInformation& from)
      : SegmentInformation(nullptr, from) {}
  SegmentInformation(SegmentInformation&& from) noexcept
    : SegmentInformation() {
    *this = ::std::move(from);
  }

  inline SegmentInformation& operator=(const SegmentInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentInformation& operator=(SegmentInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentInformation* internal_default_instance() {
    return reinterpret_cast<const SegmentInformation*>(
               &_SegmentInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SegmentInformation& a, SegmentInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentInformation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentInformation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentInformation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentInformation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SegmentInformation& from) {
    SegmentInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SegmentInformation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.SegmentInformation";
  }
  protected:
  explicit SegmentInformation(::google::protobuf::Arena* arena);
  SegmentInformation(::google::protobuf::Arena* arena, const SegmentInformation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kSegmentIdFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // uint32 segment_id = 2;
  void clear_segment_id() ;
  ::uint32_t segment_id() const;
  void set_segment_id(::uint32_t value);

  private:
  ::uint32_t _internal_segment_id() const;
  void _internal_set_segment_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.SegmentInformation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t timestamp_;
    ::uint32_t segment_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class HopField final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.HopField) */ {
 public:
  inline HopField() : HopField(nullptr) {}
  ~HopField() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HopField(::google::protobuf::internal::ConstantInitialized);

  inline HopField(const HopField& from)
      : HopField(nullptr, from) {}
  HopField(HopField&& from) noexcept
    : HopField() {
    *this = ::std::move(from);
  }

  inline HopField& operator=(const HopField& from) {
    CopyFrom(from);
    return *this;
  }
  inline HopField& operator=(HopField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HopField& default_instance() {
    return *internal_default_instance();
  }
  static inline const HopField* internal_default_instance() {
    return reinterpret_cast<const HopField*>(
               &_HopField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HopField& a, HopField& b) {
    a.Swap(&b);
  }
  inline void Swap(HopField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HopField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HopField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HopField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HopField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HopField& from) {
    HopField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HopField* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.HopField";
  }
  protected:
  explicit HopField(::google::protobuf::Arena* arena);
  HopField(::google::protobuf::Arena* arena, const HopField& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacFieldNumber = 4,
    kIngressFieldNumber = 1,
    kEgressFieldNumber = 2,
    kExpTimeFieldNumber = 3,
  };
  // bytes mac = 4;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* value);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // uint64 ingress = 1;
  void clear_ingress() ;
  ::uint64_t ingress() const;
  void set_ingress(::uint64_t value);

  private:
  ::uint64_t _internal_ingress() const;
  void _internal_set_ingress(::uint64_t value);

  public:
  // uint64 egress = 2;
  void clear_egress() ;
  ::uint64_t egress() const;
  void set_egress(::uint64_t value);

  private:
  ::uint64_t _internal_egress() const;
  void _internal_set_egress(::uint64_t value);

  public:
  // uint32 exp_time = 3;
  void clear_exp_time() ;
  ::uint32_t exp_time() const;
  void set_exp_time(::uint32_t value);

  private:
  ::uint32_t _internal_exp_time() const;
  void _internal_set_exp_time(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.HopField)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::uint64_t ingress_;
    ::uint64_t egress_;
    ::uint32_t exp_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class BeaconResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.BeaconResponse) */ {
 public:
  inline BeaconResponse() : BeaconResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeaconResponse(::google::protobuf::internal::ConstantInitialized);

  inline BeaconResponse(const BeaconResponse& from)
      : BeaconResponse(nullptr, from) {}
  BeaconResponse(BeaconResponse&& from) noexcept
    : BeaconResponse() {
    *this = ::std::move(from);
  }

  inline BeaconResponse& operator=(const BeaconResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeaconResponse& operator=(BeaconResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeaconResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeaconResponse* internal_default_instance() {
    return reinterpret_cast<const BeaconResponse*>(
               &_BeaconResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BeaconResponse& a, BeaconResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BeaconResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeaconResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeaconResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeaconResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BeaconResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BeaconResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.BeaconResponse";
  }
  protected:
  explicit BeaconResponse(::google::protobuf::Arena* arena);
  BeaconResponse(::google::protobuf::Arena* arena, const BeaconResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.BeaconResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class PeerEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.PeerEntry) */ {
 public:
  inline PeerEntry() : PeerEntry(nullptr) {}
  ~PeerEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PeerEntry(::google::protobuf::internal::ConstantInitialized);

  inline PeerEntry(const PeerEntry& from)
      : PeerEntry(nullptr, from) {}
  PeerEntry(PeerEntry&& from) noexcept
    : PeerEntry() {
    *this = ::std::move(from);
  }

  inline PeerEntry& operator=(const PeerEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerEntry& operator=(PeerEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerEntry* internal_default_instance() {
    return reinterpret_cast<const PeerEntry*>(
               &_PeerEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PeerEntry& a, PeerEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PeerEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PeerEntry& from) {
    PeerEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PeerEntry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.PeerEntry";
  }
  protected:
  explicit PeerEntry(::google::protobuf::Arena* arena);
  PeerEntry(::google::protobuf::Arena* arena, const PeerEntry& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHopFieldFieldNumber = 4,
    kPeerIsdAsFieldNumber = 1,
    kPeerInterfaceFieldNumber = 2,
    kPeerMtuFieldNumber = 3,
  };
  // .proto.control_plane.v1.HopField hop_field = 4;
  bool has_hop_field() const;
  void clear_hop_field() ;
  const ::proto::control_plane::v1::HopField& hop_field() const;
  PROTOBUF_NODISCARD ::proto::control_plane::v1::HopField* release_hop_field();
  ::proto::control_plane::v1::HopField* mutable_hop_field();
  void set_allocated_hop_field(::proto::control_plane::v1::HopField* value);
  void unsafe_arena_set_allocated_hop_field(::proto::control_plane::v1::HopField* value);
  ::proto::control_plane::v1::HopField* unsafe_arena_release_hop_field();

  private:
  const ::proto::control_plane::v1::HopField& _internal_hop_field() const;
  ::proto::control_plane::v1::HopField* _internal_mutable_hop_field();

  public:
  // uint64 peer_isd_as = 1;
  void clear_peer_isd_as() ;
  ::uint64_t peer_isd_as() const;
  void set_peer_isd_as(::uint64_t value);

  private:
  ::uint64_t _internal_peer_isd_as() const;
  void _internal_set_peer_isd_as(::uint64_t value);

  public:
  // uint64 peer_interface = 2;
  void clear_peer_interface() ;
  ::uint64_t peer_interface() const;
  void set_peer_interface(::uint64_t value);

  private:
  ::uint64_t _internal_peer_interface() const;
  void _internal_set_peer_interface(::uint64_t value);

  public:
  // uint32 peer_mtu = 3;
  void clear_peer_mtu() ;
  ::uint32_t peer_mtu() const;
  void set_peer_mtu(::uint32_t value);

  private:
  ::uint32_t _internal_peer_mtu() const;
  void _internal_set_peer_mtu(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.PeerEntry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::control_plane::v1::HopField* hop_field_;
    ::uint64_t peer_isd_as_;
    ::uint64_t peer_interface_;
    ::uint32_t peer_mtu_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class HopEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.HopEntry) */ {
 public:
  inline HopEntry() : HopEntry(nullptr) {}
  ~HopEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HopEntry(::google::protobuf::internal::ConstantInitialized);

  inline HopEntry(const HopEntry& from)
      : HopEntry(nullptr, from) {}
  HopEntry(HopEntry&& from) noexcept
    : HopEntry() {
    *this = ::std::move(from);
  }

  inline HopEntry& operator=(const HopEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline HopEntry& operator=(HopEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HopEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const HopEntry* internal_default_instance() {
    return reinterpret_cast<const HopEntry*>(
               &_HopEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HopEntry& a, HopEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(HopEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HopEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HopEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HopEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HopEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HopEntry& from) {
    HopEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HopEntry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.HopEntry";
  }
  protected:
  explicit HopEntry(::google::protobuf::Arena* arena);
  HopEntry(::google::protobuf::Arena* arena, const HopEntry& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHopFieldFieldNumber = 1,
    kIngressMtuFieldNumber = 2,
  };
  // .proto.control_plane.v1.HopField hop_field = 1;
  bool has_hop_field() const;
  void clear_hop_field() ;
  const ::proto::control_plane::v1::HopField& hop_field() const;
  PROTOBUF_NODISCARD ::proto::control_plane::v1::HopField* release_hop_field();
  ::proto::control_plane::v1::HopField* mutable_hop_field();
  void set_allocated_hop_field(::proto::control_plane::v1::HopField* value);
  void unsafe_arena_set_allocated_hop_field(::proto::control_plane::v1::HopField* value);
  ::proto::control_plane::v1::HopField* unsafe_arena_release_hop_field();

  private:
  const ::proto::control_plane::v1::HopField& _internal_hop_field() const;
  ::proto::control_plane::v1::HopField* _internal_mutable_hop_field();

  public:
  // uint32 ingress_mtu = 2;
  void clear_ingress_mtu() ;
  ::uint32_t ingress_mtu() const;
  void set_ingress_mtu(::uint32_t value);

  private:
  ::uint32_t _internal_ingress_mtu() const;
  void _internal_set_ingress_mtu(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.HopEntry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::control_plane::v1::HopField* hop_field_;
    ::uint32_t ingress_mtu_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class ASEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.ASEntry) */ {
 public:
  inline ASEntry() : ASEntry(nullptr) {}
  ~ASEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ASEntry(::google::protobuf::internal::ConstantInitialized);

  inline ASEntry(const ASEntry& from)
      : ASEntry(nullptr, from) {}
  ASEntry(ASEntry&& from) noexcept
    : ASEntry() {
    *this = ::std::move(from);
  }

  inline ASEntry& operator=(const ASEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASEntry& operator=(ASEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASEntry* internal_default_instance() {
    return reinterpret_cast<const ASEntry*>(
               &_ASEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ASEntry& a, ASEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ASEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ASEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ASEntry& from) {
    ASEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ASEntry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.ASEntry";
  }
  protected:
  explicit ASEntry(::google::protobuf::Arena* arena);
  ASEntry(::google::protobuf::Arena* arena, const ASEntry& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedFieldNumber = 1,
    kUnsignedFieldNumber = 2,
  };
  // .proto.crypto.v1.SignedMessage signed = 1;
  bool has_signed_() const;
  void clear_signed_() ;
  const ::proto::crypto::v1::SignedMessage& signed_() const;
  PROTOBUF_NODISCARD ::proto::crypto::v1::SignedMessage* release_signed_();
  ::proto::crypto::v1::SignedMessage* mutable_signed_();
  void set_allocated_signed_(::proto::crypto::v1::SignedMessage* value);
  void unsafe_arena_set_allocated_signed_(::proto::crypto::v1::SignedMessage* value);
  ::proto::crypto::v1::SignedMessage* unsafe_arena_release_signed_();

  private:
  const ::proto::crypto::v1::SignedMessage& _internal_signed_() const;
  ::proto::crypto::v1::SignedMessage* _internal_mutable_signed_();

  public:
  // .proto.control_plane.v1.PathSegmentUnsignedExtensions unsigned = 2;
  bool has_unsigned_() const;
  void clear_unsigned_() ;
  const ::proto::control_plane::v1::PathSegmentUnsignedExtensions& unsigned_() const;
  PROTOBUF_NODISCARD ::proto::control_plane::v1::PathSegmentUnsignedExtensions* release_unsigned_();
  ::proto::control_plane::v1::PathSegmentUnsignedExtensions* mutable_unsigned_();
  void set_allocated_unsigned_(::proto::control_plane::v1::PathSegmentUnsignedExtensions* value);
  void unsafe_arena_set_allocated_unsigned_(::proto::control_plane::v1::PathSegmentUnsignedExtensions* value);
  ::proto::control_plane::v1::PathSegmentUnsignedExtensions* unsafe_arena_release_unsigned_();

  private:
  const ::proto::control_plane::v1::PathSegmentUnsignedExtensions& _internal_unsigned_() const;
  ::proto::control_plane::v1::PathSegmentUnsignedExtensions* _internal_mutable_unsigned_();

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.ASEntry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::crypto::v1::SignedMessage* signed__;
    ::proto::control_plane::v1::PathSegmentUnsignedExtensions* unsigned__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class PathSegment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.PathSegment) */ {
 public:
  inline PathSegment() : PathSegment(nullptr) {}
  ~PathSegment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PathSegment(::google::protobuf::internal::ConstantInitialized);

  inline PathSegment(const PathSegment& from)
      : PathSegment(nullptr, from) {}
  PathSegment(PathSegment&& from) noexcept
    : PathSegment() {
    *this = ::std::move(from);
  }

  inline PathSegment& operator=(const PathSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathSegment& operator=(PathSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathSegment* internal_default_instance() {
    return reinterpret_cast<const PathSegment*>(
               &_PathSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PathSegment& a, PathSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(PathSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathSegment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathSegment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathSegment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PathSegment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PathSegment& from) {
    PathSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PathSegment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.PathSegment";
  }
  protected:
  explicit PathSegment(::google::protobuf::Arena* arena);
  PathSegment(::google::protobuf::Arena* arena, const PathSegment& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsEntriesFieldNumber = 2,
    kSegmentInfoFieldNumber = 1,
  };
  // repeated .proto.control_plane.v1.ASEntry as_entries = 2;
  int as_entries_size() const;
  private:
  int _internal_as_entries_size() const;

  public:
  void clear_as_entries() ;
  ::proto::control_plane::v1::ASEntry* mutable_as_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::ASEntry >*
      mutable_as_entries();
  private:
  const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::ASEntry>& _internal_as_entries() const;
  ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::ASEntry>* _internal_mutable_as_entries();
  public:
  const ::proto::control_plane::v1::ASEntry& as_entries(int index) const;
  ::proto::control_plane::v1::ASEntry* add_as_entries();
  const ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::ASEntry >&
      as_entries() const;
  // bytes segment_info = 1;
  void clear_segment_info() ;
  const std::string& segment_info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_info(Arg_&& arg, Args_... args);
  std::string* mutable_segment_info();
  PROTOBUF_NODISCARD std::string* release_segment_info();
  void set_allocated_segment_info(std::string* value);

  private:
  const std::string& _internal_segment_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_info(
      const std::string& value);
  std::string* _internal_mutable_segment_info();

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.PathSegment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::ASEntry > as_entries_;
    ::google::protobuf::internal::ArenaStringPtr segment_info_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class SegmentsResponse_Segments final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.SegmentsResponse.Segments) */ {
 public:
  inline SegmentsResponse_Segments() : SegmentsResponse_Segments(nullptr) {}
  ~SegmentsResponse_Segments() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsResponse_Segments(::google::protobuf::internal::ConstantInitialized);

  inline SegmentsResponse_Segments(const SegmentsResponse_Segments& from)
      : SegmentsResponse_Segments(nullptr, from) {}
  SegmentsResponse_Segments(SegmentsResponse_Segments&& from) noexcept
    : SegmentsResponse_Segments() {
    *this = ::std::move(from);
  }

  inline SegmentsResponse_Segments& operator=(const SegmentsResponse_Segments& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsResponse_Segments& operator=(SegmentsResponse_Segments&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsResponse_Segments& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentsResponse_Segments* internal_default_instance() {
    return reinterpret_cast<const SegmentsResponse_Segments*>(
               &_SegmentsResponse_Segments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SegmentsResponse_Segments& a, SegmentsResponse_Segments& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentsResponse_Segments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsResponse_Segments* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsResponse_Segments* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentsResponse_Segments>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentsResponse_Segments& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SegmentsResponse_Segments& from) {
    SegmentsResponse_Segments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SegmentsResponse_Segments* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.SegmentsResponse.Segments";
  }
  protected:
  explicit SegmentsResponse_Segments(::google::protobuf::Arena* arena);
  SegmentsResponse_Segments(::google::protobuf::Arena* arena, const SegmentsResponse_Segments& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // repeated .proto.control_plane.v1.PathSegment segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;

  public:
  void clear_segments() ;
  ::proto::control_plane::v1::PathSegment* mutable_segments(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PathSegment >*
      mutable_segments();
  private:
  const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>& _internal_segments() const;
  ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>* _internal_mutable_segments();
  public:
  const ::proto::control_plane::v1::PathSegment& segments(int index) const;
  ::proto::control_plane::v1::PathSegment* add_segments();
  const ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PathSegment >&
      segments() const;
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.SegmentsResponse.Segments)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PathSegment > segments_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class SegmentsRegistrationRequest_Segments final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.SegmentsRegistrationRequest.Segments) */ {
 public:
  inline SegmentsRegistrationRequest_Segments() : SegmentsRegistrationRequest_Segments(nullptr) {}
  ~SegmentsRegistrationRequest_Segments() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsRegistrationRequest_Segments(::google::protobuf::internal::ConstantInitialized);

  inline SegmentsRegistrationRequest_Segments(const SegmentsRegistrationRequest_Segments& from)
      : SegmentsRegistrationRequest_Segments(nullptr, from) {}
  SegmentsRegistrationRequest_Segments(SegmentsRegistrationRequest_Segments&& from) noexcept
    : SegmentsRegistrationRequest_Segments() {
    *this = ::std::move(from);
  }

  inline SegmentsRegistrationRequest_Segments& operator=(const SegmentsRegistrationRequest_Segments& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsRegistrationRequest_Segments& operator=(SegmentsRegistrationRequest_Segments&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsRegistrationRequest_Segments& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentsRegistrationRequest_Segments* internal_default_instance() {
    return reinterpret_cast<const SegmentsRegistrationRequest_Segments*>(
               &_SegmentsRegistrationRequest_Segments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SegmentsRegistrationRequest_Segments& a, SegmentsRegistrationRequest_Segments& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentsRegistrationRequest_Segments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsRegistrationRequest_Segments* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsRegistrationRequest_Segments* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentsRegistrationRequest_Segments>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentsRegistrationRequest_Segments& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SegmentsRegistrationRequest_Segments& from) {
    SegmentsRegistrationRequest_Segments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SegmentsRegistrationRequest_Segments* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.SegmentsRegistrationRequest.Segments";
  }
  protected:
  explicit SegmentsRegistrationRequest_Segments(::google::protobuf::Arena* arena);
  SegmentsRegistrationRequest_Segments(::google::protobuf::Arena* arena, const SegmentsRegistrationRequest_Segments& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // repeated .proto.control_plane.v1.PathSegment segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;

  public:
  void clear_segments() ;
  ::proto::control_plane::v1::PathSegment* mutable_segments(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PathSegment >*
      mutable_segments();
  private:
  const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>& _internal_segments() const;
  ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>* _internal_mutable_segments();
  public:
  const ::proto::control_plane::v1::PathSegment& segments(int index) const;
  ::proto::control_plane::v1::PathSegment* add_segments();
  const ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PathSegment >&
      segments() const;
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.SegmentsRegistrationRequest.Segments)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PathSegment > segments_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class BeaconRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.BeaconRequest) */ {
 public:
  inline BeaconRequest() : BeaconRequest(nullptr) {}
  ~BeaconRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeaconRequest(::google::protobuf::internal::ConstantInitialized);

  inline BeaconRequest(const BeaconRequest& from)
      : BeaconRequest(nullptr, from) {}
  BeaconRequest(BeaconRequest&& from) noexcept
    : BeaconRequest() {
    *this = ::std::move(from);
  }

  inline BeaconRequest& operator=(const BeaconRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeaconRequest& operator=(BeaconRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeaconRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeaconRequest* internal_default_instance() {
    return reinterpret_cast<const BeaconRequest*>(
               &_BeaconRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BeaconRequest& a, BeaconRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BeaconRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeaconRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeaconRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeaconRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BeaconRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BeaconRequest& from) {
    BeaconRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BeaconRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.BeaconRequest";
  }
  protected:
  explicit BeaconRequest(::google::protobuf::Arena* arena);
  BeaconRequest(::google::protobuf::Arena* arena, const BeaconRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentFieldNumber = 1,
  };
  // .proto.control_plane.v1.PathSegment segment = 1;
  bool has_segment() const;
  void clear_segment() ;
  const ::proto::control_plane::v1::PathSegment& segment() const;
  PROTOBUF_NODISCARD ::proto::control_plane::v1::PathSegment* release_segment();
  ::proto::control_plane::v1::PathSegment* mutable_segment();
  void set_allocated_segment(::proto::control_plane::v1::PathSegment* value);
  void unsafe_arena_set_allocated_segment(::proto::control_plane::v1::PathSegment* value);
  ::proto::control_plane::v1::PathSegment* unsafe_arena_release_segment();

  private:
  const ::proto::control_plane::v1::PathSegment& _internal_segment() const;
  ::proto::control_plane::v1::PathSegment* _internal_mutable_segment();

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.BeaconRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::control_plane::v1::PathSegment* segment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class ASEntrySignedBody final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.ASEntrySignedBody) */ {
 public:
  inline ASEntrySignedBody() : ASEntrySignedBody(nullptr) {}
  ~ASEntrySignedBody() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ASEntrySignedBody(::google::protobuf::internal::ConstantInitialized);

  inline ASEntrySignedBody(const ASEntrySignedBody& from)
      : ASEntrySignedBody(nullptr, from) {}
  ASEntrySignedBody(ASEntrySignedBody&& from) noexcept
    : ASEntrySignedBody() {
    *this = ::std::move(from);
  }

  inline ASEntrySignedBody& operator=(const ASEntrySignedBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASEntrySignedBody& operator=(ASEntrySignedBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASEntrySignedBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASEntrySignedBody* internal_default_instance() {
    return reinterpret_cast<const ASEntrySignedBody*>(
               &_ASEntrySignedBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ASEntrySignedBody& a, ASEntrySignedBody& b) {
    a.Swap(&b);
  }
  inline void Swap(ASEntrySignedBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASEntrySignedBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASEntrySignedBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASEntrySignedBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ASEntrySignedBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ASEntrySignedBody& from) {
    ASEntrySignedBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ASEntrySignedBody* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.ASEntrySignedBody";
  }
  protected:
  explicit ASEntrySignedBody(::google::protobuf::Arena* arena);
  ASEntrySignedBody(::google::protobuf::Arena* arena, const ASEntrySignedBody& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerEntriesFieldNumber = 4,
    kHopEntryFieldNumber = 3,
    kExtensionsFieldNumber = 6,
    kIsdAsFieldNumber = 1,
    kNextIsdAsFieldNumber = 2,
    kMtuFieldNumber = 5,
  };
  // repeated .proto.control_plane.v1.PeerEntry peer_entries = 4;
  int peer_entries_size() const;
  private:
  int _internal_peer_entries_size() const;

  public:
  void clear_peer_entries() ;
  ::proto::control_plane::v1::PeerEntry* mutable_peer_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PeerEntry >*
      mutable_peer_entries();
  private:
  const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PeerEntry>& _internal_peer_entries() const;
  ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PeerEntry>* _internal_mutable_peer_entries();
  public:
  const ::proto::control_plane::v1::PeerEntry& peer_entries(int index) const;
  ::proto::control_plane::v1::PeerEntry* add_peer_entries();
  const ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PeerEntry >&
      peer_entries() const;
  // .proto.control_plane.v1.HopEntry hop_entry = 3;
  bool has_hop_entry() const;
  void clear_hop_entry() ;
  const ::proto::control_plane::v1::HopEntry& hop_entry() const;
  PROTOBUF_NODISCARD ::proto::control_plane::v1::HopEntry* release_hop_entry();
  ::proto::control_plane::v1::HopEntry* mutable_hop_entry();
  void set_allocated_hop_entry(::proto::control_plane::v1::HopEntry* value);
  void unsafe_arena_set_allocated_hop_entry(::proto::control_plane::v1::HopEntry* value);
  ::proto::control_plane::v1::HopEntry* unsafe_arena_release_hop_entry();

  private:
  const ::proto::control_plane::v1::HopEntry& _internal_hop_entry() const;
  ::proto::control_plane::v1::HopEntry* _internal_mutable_hop_entry();

  public:
  // .proto.control_plane.v1.PathSegmentExtensions extensions = 6;
  bool has_extensions() const;
  void clear_extensions() ;
  const ::proto::control_plane::v1::PathSegmentExtensions& extensions() const;
  PROTOBUF_NODISCARD ::proto::control_plane::v1::PathSegmentExtensions* release_extensions();
  ::proto::control_plane::v1::PathSegmentExtensions* mutable_extensions();
  void set_allocated_extensions(::proto::control_plane::v1::PathSegmentExtensions* value);
  void unsafe_arena_set_allocated_extensions(::proto::control_plane::v1::PathSegmentExtensions* value);
  ::proto::control_plane::v1::PathSegmentExtensions* unsafe_arena_release_extensions();

  private:
  const ::proto::control_plane::v1::PathSegmentExtensions& _internal_extensions() const;
  ::proto::control_plane::v1::PathSegmentExtensions* _internal_mutable_extensions();

  public:
  // uint64 isd_as = 1;
  void clear_isd_as() ;
  ::uint64_t isd_as() const;
  void set_isd_as(::uint64_t value);

  private:
  ::uint64_t _internal_isd_as() const;
  void _internal_set_isd_as(::uint64_t value);

  public:
  // uint64 next_isd_as = 2;
  void clear_next_isd_as() ;
  ::uint64_t next_isd_as() const;
  void set_next_isd_as(::uint64_t value);

  private:
  ::uint64_t _internal_next_isd_as() const;
  void _internal_set_next_isd_as(::uint64_t value);

  public:
  // uint32 mtu = 5;
  void clear_mtu() ;
  ::uint32_t mtu() const;
  void set_mtu(::uint32_t value);

  private:
  ::uint32_t _internal_mtu() const;
  void _internal_set_mtu(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.ASEntrySignedBody)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::proto::control_plane::v1::PeerEntry > peer_entries_;
    ::proto::control_plane::v1::HopEntry* hop_entry_;
    ::proto::control_plane::v1::PathSegmentExtensions* extensions_;
    ::uint64_t isd_as_;
    ::uint64_t next_isd_as_;
    ::uint32_t mtu_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class SegmentsResponse_SegmentsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SegmentsResponse_SegmentsEntry_DoNotUse, ::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SegmentsResponse_SegmentsEntry_DoNotUse, ::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SegmentsResponse_SegmentsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsResponse_SegmentsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SegmentsResponse_SegmentsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SegmentsResponse_SegmentsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SegmentsResponse_SegmentsEntry_DoNotUse*>(
        &_SegmentsResponse_SegmentsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};
// -------------------------------------------------------------------

class SegmentsRegistrationRequest_SegmentsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SegmentsRegistrationRequest_SegmentsEntry_DoNotUse, ::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SegmentsRegistrationRequest_SegmentsEntry_DoNotUse, ::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SegmentsRegistrationRequest_SegmentsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsRegistrationRequest_SegmentsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SegmentsRegistrationRequest_SegmentsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SegmentsRegistrationRequest_SegmentsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SegmentsRegistrationRequest_SegmentsEntry_DoNotUse*>(
        &_SegmentsRegistrationRequest_SegmentsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};
// -------------------------------------------------------------------

class SegmentsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.SegmentsResponse) */ {
 public:
  inline SegmentsResponse() : SegmentsResponse(nullptr) {}
  ~SegmentsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsResponse(::google::protobuf::internal::ConstantInitialized);

  inline SegmentsResponse(const SegmentsResponse& from)
      : SegmentsResponse(nullptr, from) {}
  SegmentsResponse(SegmentsResponse&& from) noexcept
    : SegmentsResponse() {
    *this = ::std::move(from);
  }

  inline SegmentsResponse& operator=(const SegmentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsResponse& operator=(SegmentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentsResponse* internal_default_instance() {
    return reinterpret_cast<const SegmentsResponse*>(
               &_SegmentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SegmentsResponse& a, SegmentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SegmentsResponse& from) {
    SegmentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SegmentsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.SegmentsResponse";
  }
  protected:
  explicit SegmentsResponse(::google::protobuf::Arena* arena);
  SegmentsResponse(::google::protobuf::Arena* arena, const SegmentsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Segments = SegmentsResponse_Segments;

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
    kDeprecatedSignedRevocationsFieldNumber = 1000,
  };
  // map<int32, .proto.control_plane.v1.SegmentsResponse.Segments> segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;

  public:
  void clear_segments() ;
  const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>& segments() const;
  ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>* mutable_segments();

  private:
  const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>& _internal_segments() const;
  ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>* _internal_mutable_segments();

  public:
  // repeated bytes deprecated_signed_revocations = 1000;
  int deprecated_signed_revocations_size() const;
  private:
  int _internal_deprecated_signed_revocations_size() const;

  public:
  void clear_deprecated_signed_revocations() ;
  const std::string& deprecated_signed_revocations(int index) const;
  std::string* mutable_deprecated_signed_revocations(int index);
  void set_deprecated_signed_revocations(int index, const std::string& value);
  void set_deprecated_signed_revocations(int index, std::string&& value);
  void set_deprecated_signed_revocations(int index, const char* value);
  void set_deprecated_signed_revocations(int index, const void* value, std::size_t size);
  void set_deprecated_signed_revocations(int index, absl::string_view value);
  std::string* add_deprecated_signed_revocations();
  void add_deprecated_signed_revocations(const std::string& value);
  void add_deprecated_signed_revocations(std::string&& value);
  void add_deprecated_signed_revocations(const char* value);
  void add_deprecated_signed_revocations(const void* value, std::size_t size);
  void add_deprecated_signed_revocations(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& deprecated_signed_revocations() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_deprecated_signed_revocations();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_deprecated_signed_revocations() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_deprecated_signed_revocations();

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.SegmentsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<SegmentsResponse_SegmentsEntry_DoNotUse, ::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        segments_;
    ::google::protobuf::RepeatedPtrField<std::string> deprecated_signed_revocations_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};// -------------------------------------------------------------------

class SegmentsRegistrationRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.control_plane.v1.SegmentsRegistrationRequest) */ {
 public:
  inline SegmentsRegistrationRequest() : SegmentsRegistrationRequest(nullptr) {}
  ~SegmentsRegistrationRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsRegistrationRequest(::google::protobuf::internal::ConstantInitialized);

  inline SegmentsRegistrationRequest(const SegmentsRegistrationRequest& from)
      : SegmentsRegistrationRequest(nullptr, from) {}
  SegmentsRegistrationRequest(SegmentsRegistrationRequest&& from) noexcept
    : SegmentsRegistrationRequest() {
    *this = ::std::move(from);
  }

  inline SegmentsRegistrationRequest& operator=(const SegmentsRegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsRegistrationRequest& operator=(SegmentsRegistrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsRegistrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentsRegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const SegmentsRegistrationRequest*>(
               &_SegmentsRegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SegmentsRegistrationRequest& a, SegmentsRegistrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentsRegistrationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsRegistrationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsRegistrationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentsRegistrationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentsRegistrationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SegmentsRegistrationRequest& from) {
    SegmentsRegistrationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SegmentsRegistrationRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.control_plane.v1.SegmentsRegistrationRequest";
  }
  protected:
  explicit SegmentsRegistrationRequest(::google::protobuf::Arena* arena);
  SegmentsRegistrationRequest(::google::protobuf::Arena* arena, const SegmentsRegistrationRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Segments = SegmentsRegistrationRequest_Segments;

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // map<int32, .proto.control_plane.v1.SegmentsRegistrationRequest.Segments> segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;

  public:
  void clear_segments() ;
  const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>& segments() const;
  ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>* mutable_segments();

  private:
  const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>& _internal_segments() const;
  ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>* _internal_mutable_segments();

  public:
  // @@protoc_insertion_point(class_scope:proto.control_plane.v1.SegmentsRegistrationRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<SegmentsRegistrationRequest_SegmentsEntry_DoNotUse, ::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        segments_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SegmentsRequest

// uint64 src_isd_as = 1;
inline void SegmentsRequest::clear_src_isd_as() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.src_isd_as_ = ::uint64_t{0u};
}
inline ::uint64_t SegmentsRequest::src_isd_as() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.SegmentsRequest.src_isd_as)
  return _internal_src_isd_as();
}
inline void SegmentsRequest::set_src_isd_as(::uint64_t value) {
  _internal_set_src_isd_as(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.SegmentsRequest.src_isd_as)
}
inline ::uint64_t SegmentsRequest::_internal_src_isd_as() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.src_isd_as_;
}
inline void SegmentsRequest::_internal_set_src_isd_as(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.src_isd_as_ = value;
}

// uint64 dst_isd_as = 2;
inline void SegmentsRequest::clear_dst_isd_as() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dst_isd_as_ = ::uint64_t{0u};
}
inline ::uint64_t SegmentsRequest::dst_isd_as() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.SegmentsRequest.dst_isd_as)
  return _internal_dst_isd_as();
}
inline void SegmentsRequest::set_dst_isd_as(::uint64_t value) {
  _internal_set_dst_isd_as(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.SegmentsRequest.dst_isd_as)
}
inline ::uint64_t SegmentsRequest::_internal_dst_isd_as() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dst_isd_as_;
}
inline void SegmentsRequest::_internal_set_dst_isd_as(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dst_isd_as_ = value;
}

// -------------------------------------------------------------------

// SegmentsResponse_Segments

// repeated .proto.control_plane.v1.PathSegment segments = 1;
inline int SegmentsResponse_Segments::_internal_segments_size() const {
  return _internal_segments().size();
}
inline int SegmentsResponse_Segments::segments_size() const {
  return _internal_segments_size();
}
inline void SegmentsResponse_Segments::clear_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segments_.Clear();
}
inline ::proto::control_plane::v1::PathSegment* SegmentsResponse_Segments::mutable_segments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.SegmentsResponse.Segments.segments)
  return _internal_mutable_segments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>* SegmentsResponse_Segments::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:proto.control_plane.v1.SegmentsResponse.Segments.segments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_segments();
}
inline const ::proto::control_plane::v1::PathSegment& SegmentsResponse_Segments::segments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.SegmentsResponse.Segments.segments)
  return _internal_segments().Get(index);
}
inline ::proto::control_plane::v1::PathSegment* SegmentsResponse_Segments::add_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::proto::control_plane::v1::PathSegment* _add = _internal_mutable_segments()->Add();
  // @@protoc_insertion_point(field_add:proto.control_plane.v1.SegmentsResponse.Segments.segments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>& SegmentsResponse_Segments::segments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:proto.control_plane.v1.SegmentsResponse.Segments.segments)
  return _internal_segments();
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>&
SegmentsResponse_Segments::_internal_segments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segments_;
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>*
SegmentsResponse_Segments::_internal_mutable_segments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.segments_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SegmentsResponse

// map<int32, .proto.control_plane.v1.SegmentsResponse.Segments> segments = 1;
inline int SegmentsResponse::_internal_segments_size() const {
  return _internal_segments().size();
}
inline int SegmentsResponse::segments_size() const {
  return _internal_segments_size();
}
inline void SegmentsResponse::clear_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segments_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>& SegmentsResponse::_internal_segments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segments_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>& SegmentsResponse::segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:proto.control_plane.v1.SegmentsResponse.segments)
  return _internal_segments();
}
inline ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>* SegmentsResponse::_internal_mutable_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.segments_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsResponse_Segments>* SegmentsResponse::mutable_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:proto.control_plane.v1.SegmentsResponse.segments)
  return _internal_mutable_segments();
}

// repeated bytes deprecated_signed_revocations = 1000;
inline int SegmentsResponse::_internal_deprecated_signed_revocations_size() const {
  return _internal_deprecated_signed_revocations().size();
}
inline int SegmentsResponse::deprecated_signed_revocations_size() const {
  return _internal_deprecated_signed_revocations_size();
}
inline void SegmentsResponse::clear_deprecated_signed_revocations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deprecated_signed_revocations_.Clear();
}
inline std::string* SegmentsResponse::add_deprecated_signed_revocations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_deprecated_signed_revocations()->Add();
  // @@protoc_insertion_point(field_add_mutable:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
  return _s;
}
inline const std::string& SegmentsResponse::deprecated_signed_revocations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
  return _internal_deprecated_signed_revocations().Get(index);
}
inline std::string* SegmentsResponse::mutable_deprecated_signed_revocations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
  return _internal_mutable_deprecated_signed_revocations()->Mutable(index);
}
inline void SegmentsResponse::set_deprecated_signed_revocations(int index, const std::string& value) {
  _internal_mutable_deprecated_signed_revocations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::set_deprecated_signed_revocations(int index, std::string&& value) {
  _internal_mutable_deprecated_signed_revocations()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::set_deprecated_signed_revocations(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_deprecated_signed_revocations()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::set_deprecated_signed_revocations(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_deprecated_signed_revocations()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::set_deprecated_signed_revocations(int index, absl::string_view value) {
  _internal_mutable_deprecated_signed_revocations()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::add_deprecated_signed_revocations(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deprecated_signed_revocations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::add_deprecated_signed_revocations(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deprecated_signed_revocations()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::add_deprecated_signed_revocations(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deprecated_signed_revocations()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::add_deprecated_signed_revocations(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deprecated_signed_revocations()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline void SegmentsResponse::add_deprecated_signed_revocations(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deprecated_signed_revocations()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SegmentsResponse::deprecated_signed_revocations() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
  return _internal_deprecated_signed_revocations();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SegmentsResponse::mutable_deprecated_signed_revocations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:proto.control_plane.v1.SegmentsResponse.deprecated_signed_revocations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_deprecated_signed_revocations();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SegmentsResponse::_internal_deprecated_signed_revocations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deprecated_signed_revocations_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SegmentsResponse::_internal_mutable_deprecated_signed_revocations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.deprecated_signed_revocations_;
}

// -------------------------------------------------------------------

// SegmentsRegistrationRequest_Segments

// repeated .proto.control_plane.v1.PathSegment segments = 1;
inline int SegmentsRegistrationRequest_Segments::_internal_segments_size() const {
  return _internal_segments().size();
}
inline int SegmentsRegistrationRequest_Segments::segments_size() const {
  return _internal_segments_size();
}
inline void SegmentsRegistrationRequest_Segments::clear_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segments_.Clear();
}
inline ::proto::control_plane::v1::PathSegment* SegmentsRegistrationRequest_Segments::mutable_segments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.SegmentsRegistrationRequest.Segments.segments)
  return _internal_mutable_segments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>* SegmentsRegistrationRequest_Segments::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:proto.control_plane.v1.SegmentsRegistrationRequest.Segments.segments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_segments();
}
inline const ::proto::control_plane::v1::PathSegment& SegmentsRegistrationRequest_Segments::segments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.SegmentsRegistrationRequest.Segments.segments)
  return _internal_segments().Get(index);
}
inline ::proto::control_plane::v1::PathSegment* SegmentsRegistrationRequest_Segments::add_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::proto::control_plane::v1::PathSegment* _add = _internal_mutable_segments()->Add();
  // @@protoc_insertion_point(field_add:proto.control_plane.v1.SegmentsRegistrationRequest.Segments.segments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>& SegmentsRegistrationRequest_Segments::segments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:proto.control_plane.v1.SegmentsRegistrationRequest.Segments.segments)
  return _internal_segments();
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>&
SegmentsRegistrationRequest_Segments::_internal_segments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segments_;
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PathSegment>*
SegmentsRegistrationRequest_Segments::_internal_mutable_segments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.segments_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SegmentsRegistrationRequest

// map<int32, .proto.control_plane.v1.SegmentsRegistrationRequest.Segments> segments = 1;
inline int SegmentsRegistrationRequest::_internal_segments_size() const {
  return _internal_segments().size();
}
inline int SegmentsRegistrationRequest::segments_size() const {
  return _internal_segments_size();
}
inline void SegmentsRegistrationRequest::clear_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segments_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>& SegmentsRegistrationRequest::_internal_segments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segments_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>& SegmentsRegistrationRequest::segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:proto.control_plane.v1.SegmentsRegistrationRequest.segments)
  return _internal_segments();
}
inline ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>* SegmentsRegistrationRequest::_internal_mutable_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.segments_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::proto::control_plane::v1::SegmentsRegistrationRequest_Segments>* SegmentsRegistrationRequest::mutable_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:proto.control_plane.v1.SegmentsRegistrationRequest.segments)
  return _internal_mutable_segments();
}

// -------------------------------------------------------------------

// SegmentsRegistrationResponse

// -------------------------------------------------------------------

// BeaconRequest

// .proto.control_plane.v1.PathSegment segment = 1;
inline bool BeaconRequest::has_segment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.segment_ != nullptr);
  return value;
}
inline void BeaconRequest::clear_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.segment_ != nullptr) _impl_.segment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::control_plane::v1::PathSegment& BeaconRequest::_internal_segment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::control_plane::v1::PathSegment* p = _impl_.segment_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::control_plane::v1::PathSegment&>(::proto::control_plane::v1::_PathSegment_default_instance_);
}
inline const ::proto::control_plane::v1::PathSegment& BeaconRequest::segment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.BeaconRequest.segment)
  return _internal_segment();
}
inline void BeaconRequest::unsafe_arena_set_allocated_segment(::proto::control_plane::v1::PathSegment* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.segment_);
  }
  _impl_.segment_ = reinterpret_cast<::proto::control_plane::v1::PathSegment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.control_plane.v1.BeaconRequest.segment)
}
inline ::proto::control_plane::v1::PathSegment* BeaconRequest::release_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::PathSegment* released = _impl_.segment_;
  _impl_.segment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::control_plane::v1::PathSegment* BeaconRequest::unsafe_arena_release_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.BeaconRequest.segment)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::PathSegment* temp = _impl_.segment_;
  _impl_.segment_ = nullptr;
  return temp;
}
inline ::proto::control_plane::v1::PathSegment* BeaconRequest::_internal_mutable_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::control_plane::v1::PathSegment>(GetArena());
    _impl_.segment_ = reinterpret_cast<::proto::control_plane::v1::PathSegment*>(p);
  }
  return _impl_.segment_;
}
inline ::proto::control_plane::v1::PathSegment* BeaconRequest::mutable_segment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::control_plane::v1::PathSegment* _msg = _internal_mutable_segment();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.BeaconRequest.segment)
  return _msg;
}
inline void BeaconRequest::set_allocated_segment(::proto::control_plane::v1::PathSegment* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::control_plane::v1::PathSegment*>(_impl_.segment_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::control_plane::v1::PathSegment*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.segment_ = reinterpret_cast<::proto::control_plane::v1::PathSegment*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.BeaconRequest.segment)
}

// -------------------------------------------------------------------

// BeaconResponse

// -------------------------------------------------------------------

// PathSegment

// bytes segment_info = 1;
inline void PathSegment::clear_segment_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_info_.ClearToEmpty();
}
inline const std::string& PathSegment::segment_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.PathSegment.segment_info)
  return _internal_segment_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PathSegment::set_segment_info(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.segment_info_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.PathSegment.segment_info)
}
inline std::string* PathSegment::mutable_segment_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_info();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.PathSegment.segment_info)
  return _s;
}
inline const std::string& PathSegment::_internal_segment_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_info_.Get();
}
inline void PathSegment::_internal_set_segment_info(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.segment_info_.Set(value, GetArena());
}
inline std::string* PathSegment::_internal_mutable_segment_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.segment_info_.Mutable( GetArena());
}
inline std::string* PathSegment::release_segment_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.PathSegment.segment_info)
  return _impl_.segment_info_.Release();
}
inline void PathSegment::set_allocated_segment_info(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_info_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.segment_info_.IsDefault()) {
          _impl_.segment_info_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.PathSegment.segment_info)
}

// repeated .proto.control_plane.v1.ASEntry as_entries = 2;
inline int PathSegment::_internal_as_entries_size() const {
  return _internal_as_entries().size();
}
inline int PathSegment::as_entries_size() const {
  return _internal_as_entries_size();
}
inline void PathSegment::clear_as_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.as_entries_.Clear();
}
inline ::proto::control_plane::v1::ASEntry* PathSegment::mutable_as_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.PathSegment.as_entries)
  return _internal_mutable_as_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::ASEntry>* PathSegment::mutable_as_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:proto.control_plane.v1.PathSegment.as_entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_as_entries();
}
inline const ::proto::control_plane::v1::ASEntry& PathSegment::as_entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.PathSegment.as_entries)
  return _internal_as_entries().Get(index);
}
inline ::proto::control_plane::v1::ASEntry* PathSegment::add_as_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::proto::control_plane::v1::ASEntry* _add = _internal_mutable_as_entries()->Add();
  // @@protoc_insertion_point(field_add:proto.control_plane.v1.PathSegment.as_entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::ASEntry>& PathSegment::as_entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:proto.control_plane.v1.PathSegment.as_entries)
  return _internal_as_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::ASEntry>&
PathSegment::_internal_as_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.as_entries_;
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::ASEntry>*
PathSegment::_internal_mutable_as_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.as_entries_;
}

// -------------------------------------------------------------------

// SegmentInformation

// int64 timestamp = 1;
inline void SegmentInformation::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t SegmentInformation::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.SegmentInformation.timestamp)
  return _internal_timestamp();
}
inline void SegmentInformation::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.SegmentInformation.timestamp)
}
inline ::int64_t SegmentInformation::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void SegmentInformation::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// uint32 segment_id = 2;
inline void SegmentInformation::clear_segment_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_id_ = 0u;
}
inline ::uint32_t SegmentInformation::segment_id() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.SegmentInformation.segment_id)
  return _internal_segment_id();
}
inline void SegmentInformation::set_segment_id(::uint32_t value) {
  _internal_set_segment_id(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.SegmentInformation.segment_id)
}
inline ::uint32_t SegmentInformation::_internal_segment_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_id_;
}
inline void SegmentInformation::_internal_set_segment_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.segment_id_ = value;
}

// -------------------------------------------------------------------

// ASEntry

// .proto.crypto.v1.SignedMessage signed = 1;
inline bool ASEntry::has_signed_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signed__ != nullptr);
  return value;
}
inline const ::proto::crypto::v1::SignedMessage& ASEntry::_internal_signed_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::crypto::v1::SignedMessage* p = _impl_.signed__;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::crypto::v1::SignedMessage&>(::proto::crypto::v1::_SignedMessage_default_instance_);
}
inline const ::proto::crypto::v1::SignedMessage& ASEntry::signed_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntry.signed)
  return _internal_signed_();
}
inline void ASEntry::unsafe_arena_set_allocated_signed_(::proto::crypto::v1::SignedMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signed__);
  }
  _impl_.signed__ = reinterpret_cast<::proto::crypto::v1::SignedMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.control_plane.v1.ASEntry.signed)
}
inline ::proto::crypto::v1::SignedMessage* ASEntry::release_signed_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::crypto::v1::SignedMessage* released = _impl_.signed__;
  _impl_.signed__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::crypto::v1::SignedMessage* ASEntry::unsafe_arena_release_signed_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.ASEntry.signed)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::crypto::v1::SignedMessage* temp = _impl_.signed__;
  _impl_.signed__ = nullptr;
  return temp;
}
inline ::proto::crypto::v1::SignedMessage* ASEntry::_internal_mutable_signed_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.signed__ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::crypto::v1::SignedMessage>(GetArena());
    _impl_.signed__ = reinterpret_cast<::proto::crypto::v1::SignedMessage*>(p);
  }
  return _impl_.signed__;
}
inline ::proto::crypto::v1::SignedMessage* ASEntry::mutable_signed_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::crypto::v1::SignedMessage* _msg = _internal_mutable_signed_();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.ASEntry.signed)
  return _msg;
}
inline void ASEntry::set_allocated_signed_(::proto::crypto::v1::SignedMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signed__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.signed__ = reinterpret_cast<::proto::crypto::v1::SignedMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.ASEntry.signed)
}

// .proto.control_plane.v1.PathSegmentUnsignedExtensions unsigned = 2;
inline bool ASEntry::has_unsigned_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unsigned__ != nullptr);
  return value;
}
inline const ::proto::control_plane::v1::PathSegmentUnsignedExtensions& ASEntry::_internal_unsigned_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::control_plane::v1::PathSegmentUnsignedExtensions* p = _impl_.unsigned__;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::control_plane::v1::PathSegmentUnsignedExtensions&>(::proto::control_plane::v1::_PathSegmentUnsignedExtensions_default_instance_);
}
inline const ::proto::control_plane::v1::PathSegmentUnsignedExtensions& ASEntry::unsigned_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntry.unsigned)
  return _internal_unsigned_();
}
inline void ASEntry::unsafe_arena_set_allocated_unsigned_(::proto::control_plane::v1::PathSegmentUnsignedExtensions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unsigned__);
  }
  _impl_.unsigned__ = reinterpret_cast<::proto::control_plane::v1::PathSegmentUnsignedExtensions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.control_plane.v1.ASEntry.unsigned)
}
inline ::proto::control_plane::v1::PathSegmentUnsignedExtensions* ASEntry::release_unsigned_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::control_plane::v1::PathSegmentUnsignedExtensions* released = _impl_.unsigned__;
  _impl_.unsigned__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::control_plane::v1::PathSegmentUnsignedExtensions* ASEntry::unsafe_arena_release_unsigned_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.ASEntry.unsigned)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::control_plane::v1::PathSegmentUnsignedExtensions* temp = _impl_.unsigned__;
  _impl_.unsigned__ = nullptr;
  return temp;
}
inline ::proto::control_plane::v1::PathSegmentUnsignedExtensions* ASEntry::_internal_mutable_unsigned_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.unsigned__ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::control_plane::v1::PathSegmentUnsignedExtensions>(GetArena());
    _impl_.unsigned__ = reinterpret_cast<::proto::control_plane::v1::PathSegmentUnsignedExtensions*>(p);
  }
  return _impl_.unsigned__;
}
inline ::proto::control_plane::v1::PathSegmentUnsignedExtensions* ASEntry::mutable_unsigned_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::control_plane::v1::PathSegmentUnsignedExtensions* _msg = _internal_mutable_unsigned_();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.ASEntry.unsigned)
  return _msg;
}
inline void ASEntry::set_allocated_unsigned_(::proto::control_plane::v1::PathSegmentUnsignedExtensions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unsigned__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.unsigned__ = reinterpret_cast<::proto::control_plane::v1::PathSegmentUnsignedExtensions*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.ASEntry.unsigned)
}

// -------------------------------------------------------------------

// ASEntrySignedBody

// uint64 isd_as = 1;
inline void ASEntrySignedBody::clear_isd_as() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isd_as_ = ::uint64_t{0u};
}
inline ::uint64_t ASEntrySignedBody::isd_as() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntrySignedBody.isd_as)
  return _internal_isd_as();
}
inline void ASEntrySignedBody::set_isd_as(::uint64_t value) {
  _internal_set_isd_as(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.ASEntrySignedBody.isd_as)
}
inline ::uint64_t ASEntrySignedBody::_internal_isd_as() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isd_as_;
}
inline void ASEntrySignedBody::_internal_set_isd_as(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.isd_as_ = value;
}

// uint64 next_isd_as = 2;
inline void ASEntrySignedBody::clear_next_isd_as() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_isd_as_ = ::uint64_t{0u};
}
inline ::uint64_t ASEntrySignedBody::next_isd_as() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntrySignedBody.next_isd_as)
  return _internal_next_isd_as();
}
inline void ASEntrySignedBody::set_next_isd_as(::uint64_t value) {
  _internal_set_next_isd_as(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.ASEntrySignedBody.next_isd_as)
}
inline ::uint64_t ASEntrySignedBody::_internal_next_isd_as() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_isd_as_;
}
inline void ASEntrySignedBody::_internal_set_next_isd_as(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_isd_as_ = value;
}

// .proto.control_plane.v1.HopEntry hop_entry = 3;
inline bool ASEntrySignedBody::has_hop_entry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hop_entry_ != nullptr);
  return value;
}
inline void ASEntrySignedBody::clear_hop_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.hop_entry_ != nullptr) _impl_.hop_entry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::control_plane::v1::HopEntry& ASEntrySignedBody::_internal_hop_entry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::control_plane::v1::HopEntry* p = _impl_.hop_entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::control_plane::v1::HopEntry&>(::proto::control_plane::v1::_HopEntry_default_instance_);
}
inline const ::proto::control_plane::v1::HopEntry& ASEntrySignedBody::hop_entry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntrySignedBody.hop_entry)
  return _internal_hop_entry();
}
inline void ASEntrySignedBody::unsafe_arena_set_allocated_hop_entry(::proto::control_plane::v1::HopEntry* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hop_entry_);
  }
  _impl_.hop_entry_ = reinterpret_cast<::proto::control_plane::v1::HopEntry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.control_plane.v1.ASEntrySignedBody.hop_entry)
}
inline ::proto::control_plane::v1::HopEntry* ASEntrySignedBody::release_hop_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::HopEntry* released = _impl_.hop_entry_;
  _impl_.hop_entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::control_plane::v1::HopEntry* ASEntrySignedBody::unsafe_arena_release_hop_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.ASEntrySignedBody.hop_entry)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::HopEntry* temp = _impl_.hop_entry_;
  _impl_.hop_entry_ = nullptr;
  return temp;
}
inline ::proto::control_plane::v1::HopEntry* ASEntrySignedBody::_internal_mutable_hop_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hop_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::control_plane::v1::HopEntry>(GetArena());
    _impl_.hop_entry_ = reinterpret_cast<::proto::control_plane::v1::HopEntry*>(p);
  }
  return _impl_.hop_entry_;
}
inline ::proto::control_plane::v1::HopEntry* ASEntrySignedBody::mutable_hop_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::control_plane::v1::HopEntry* _msg = _internal_mutable_hop_entry();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.ASEntrySignedBody.hop_entry)
  return _msg;
}
inline void ASEntrySignedBody::set_allocated_hop_entry(::proto::control_plane::v1::HopEntry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::control_plane::v1::HopEntry*>(_impl_.hop_entry_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::control_plane::v1::HopEntry*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hop_entry_ = reinterpret_cast<::proto::control_plane::v1::HopEntry*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.ASEntrySignedBody.hop_entry)
}

// repeated .proto.control_plane.v1.PeerEntry peer_entries = 4;
inline int ASEntrySignedBody::_internal_peer_entries_size() const {
  return _internal_peer_entries().size();
}
inline int ASEntrySignedBody::peer_entries_size() const {
  return _internal_peer_entries_size();
}
inline void ASEntrySignedBody::clear_peer_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peer_entries_.Clear();
}
inline ::proto::control_plane::v1::PeerEntry* ASEntrySignedBody::mutable_peer_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.ASEntrySignedBody.peer_entries)
  return _internal_mutable_peer_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PeerEntry>* ASEntrySignedBody::mutable_peer_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:proto.control_plane.v1.ASEntrySignedBody.peer_entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_peer_entries();
}
inline const ::proto::control_plane::v1::PeerEntry& ASEntrySignedBody::peer_entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntrySignedBody.peer_entries)
  return _internal_peer_entries().Get(index);
}
inline ::proto::control_plane::v1::PeerEntry* ASEntrySignedBody::add_peer_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::proto::control_plane::v1::PeerEntry* _add = _internal_mutable_peer_entries()->Add();
  // @@protoc_insertion_point(field_add:proto.control_plane.v1.ASEntrySignedBody.peer_entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PeerEntry>& ASEntrySignedBody::peer_entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:proto.control_plane.v1.ASEntrySignedBody.peer_entries)
  return _internal_peer_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PeerEntry>&
ASEntrySignedBody::_internal_peer_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.peer_entries_;
}
inline ::google::protobuf::RepeatedPtrField<::proto::control_plane::v1::PeerEntry>*
ASEntrySignedBody::_internal_mutable_peer_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.peer_entries_;
}

// uint32 mtu = 5;
inline void ASEntrySignedBody::clear_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mtu_ = 0u;
}
inline ::uint32_t ASEntrySignedBody::mtu() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntrySignedBody.mtu)
  return _internal_mtu();
}
inline void ASEntrySignedBody::set_mtu(::uint32_t value) {
  _internal_set_mtu(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.ASEntrySignedBody.mtu)
}
inline ::uint32_t ASEntrySignedBody::_internal_mtu() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mtu_;
}
inline void ASEntrySignedBody::_internal_set_mtu(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mtu_ = value;
}

// .proto.control_plane.v1.PathSegmentExtensions extensions = 6;
inline bool ASEntrySignedBody::has_extensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extensions_ != nullptr);
  return value;
}
inline const ::proto::control_plane::v1::PathSegmentExtensions& ASEntrySignedBody::_internal_extensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::control_plane::v1::PathSegmentExtensions* p = _impl_.extensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::control_plane::v1::PathSegmentExtensions&>(::proto::control_plane::v1::_PathSegmentExtensions_default_instance_);
}
inline const ::proto::control_plane::v1::PathSegmentExtensions& ASEntrySignedBody::extensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.ASEntrySignedBody.extensions)
  return _internal_extensions();
}
inline void ASEntrySignedBody::unsafe_arena_set_allocated_extensions(::proto::control_plane::v1::PathSegmentExtensions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extensions_);
  }
  _impl_.extensions_ = reinterpret_cast<::proto::control_plane::v1::PathSegmentExtensions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.control_plane.v1.ASEntrySignedBody.extensions)
}
inline ::proto::control_plane::v1::PathSegmentExtensions* ASEntrySignedBody::release_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::control_plane::v1::PathSegmentExtensions* released = _impl_.extensions_;
  _impl_.extensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::control_plane::v1::PathSegmentExtensions* ASEntrySignedBody::unsafe_arena_release_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.ASEntrySignedBody.extensions)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::control_plane::v1::PathSegmentExtensions* temp = _impl_.extensions_;
  _impl_.extensions_ = nullptr;
  return temp;
}
inline ::proto::control_plane::v1::PathSegmentExtensions* ASEntrySignedBody::_internal_mutable_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.extensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::control_plane::v1::PathSegmentExtensions>(GetArena());
    _impl_.extensions_ = reinterpret_cast<::proto::control_plane::v1::PathSegmentExtensions*>(p);
  }
  return _impl_.extensions_;
}
inline ::proto::control_plane::v1::PathSegmentExtensions* ASEntrySignedBody::mutable_extensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::control_plane::v1::PathSegmentExtensions* _msg = _internal_mutable_extensions();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.ASEntrySignedBody.extensions)
  return _msg;
}
inline void ASEntrySignedBody::set_allocated_extensions(::proto::control_plane::v1::PathSegmentExtensions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.extensions_ = reinterpret_cast<::proto::control_plane::v1::PathSegmentExtensions*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.ASEntrySignedBody.extensions)
}

// -------------------------------------------------------------------

// HopEntry

// .proto.control_plane.v1.HopField hop_field = 1;
inline bool HopEntry::has_hop_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hop_field_ != nullptr);
  return value;
}
inline void HopEntry::clear_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.hop_field_ != nullptr) _impl_.hop_field_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::control_plane::v1::HopField& HopEntry::_internal_hop_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::control_plane::v1::HopField* p = _impl_.hop_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::control_plane::v1::HopField&>(::proto::control_plane::v1::_HopField_default_instance_);
}
inline const ::proto::control_plane::v1::HopField& HopEntry::hop_field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.HopEntry.hop_field)
  return _internal_hop_field();
}
inline void HopEntry::unsafe_arena_set_allocated_hop_field(::proto::control_plane::v1::HopField* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hop_field_);
  }
  _impl_.hop_field_ = reinterpret_cast<::proto::control_plane::v1::HopField*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.control_plane.v1.HopEntry.hop_field)
}
inline ::proto::control_plane::v1::HopField* HopEntry::release_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::HopField* released = _impl_.hop_field_;
  _impl_.hop_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::control_plane::v1::HopField* HopEntry::unsafe_arena_release_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.HopEntry.hop_field)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::HopField* temp = _impl_.hop_field_;
  _impl_.hop_field_ = nullptr;
  return temp;
}
inline ::proto::control_plane::v1::HopField* HopEntry::_internal_mutable_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hop_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::control_plane::v1::HopField>(GetArena());
    _impl_.hop_field_ = reinterpret_cast<::proto::control_plane::v1::HopField*>(p);
  }
  return _impl_.hop_field_;
}
inline ::proto::control_plane::v1::HopField* HopEntry::mutable_hop_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::control_plane::v1::HopField* _msg = _internal_mutable_hop_field();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.HopEntry.hop_field)
  return _msg;
}
inline void HopEntry::set_allocated_hop_field(::proto::control_plane::v1::HopField* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::control_plane::v1::HopField*>(_impl_.hop_field_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::control_plane::v1::HopField*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hop_field_ = reinterpret_cast<::proto::control_plane::v1::HopField*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.HopEntry.hop_field)
}

// uint32 ingress_mtu = 2;
inline void HopEntry::clear_ingress_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ingress_mtu_ = 0u;
}
inline ::uint32_t HopEntry::ingress_mtu() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.HopEntry.ingress_mtu)
  return _internal_ingress_mtu();
}
inline void HopEntry::set_ingress_mtu(::uint32_t value) {
  _internal_set_ingress_mtu(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.HopEntry.ingress_mtu)
}
inline ::uint32_t HopEntry::_internal_ingress_mtu() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ingress_mtu_;
}
inline void HopEntry::_internal_set_ingress_mtu(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ingress_mtu_ = value;
}

// -------------------------------------------------------------------

// PeerEntry

// uint64 peer_isd_as = 1;
inline void PeerEntry::clear_peer_isd_as() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peer_isd_as_ = ::uint64_t{0u};
}
inline ::uint64_t PeerEntry::peer_isd_as() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.PeerEntry.peer_isd_as)
  return _internal_peer_isd_as();
}
inline void PeerEntry::set_peer_isd_as(::uint64_t value) {
  _internal_set_peer_isd_as(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.PeerEntry.peer_isd_as)
}
inline ::uint64_t PeerEntry::_internal_peer_isd_as() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.peer_isd_as_;
}
inline void PeerEntry::_internal_set_peer_isd_as(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.peer_isd_as_ = value;
}

// uint64 peer_interface = 2;
inline void PeerEntry::clear_peer_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peer_interface_ = ::uint64_t{0u};
}
inline ::uint64_t PeerEntry::peer_interface() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.PeerEntry.peer_interface)
  return _internal_peer_interface();
}
inline void PeerEntry::set_peer_interface(::uint64_t value) {
  _internal_set_peer_interface(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.PeerEntry.peer_interface)
}
inline ::uint64_t PeerEntry::_internal_peer_interface() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.peer_interface_;
}
inline void PeerEntry::_internal_set_peer_interface(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.peer_interface_ = value;
}

// uint32 peer_mtu = 3;
inline void PeerEntry::clear_peer_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peer_mtu_ = 0u;
}
inline ::uint32_t PeerEntry::peer_mtu() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.PeerEntry.peer_mtu)
  return _internal_peer_mtu();
}
inline void PeerEntry::set_peer_mtu(::uint32_t value) {
  _internal_set_peer_mtu(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.PeerEntry.peer_mtu)
}
inline ::uint32_t PeerEntry::_internal_peer_mtu() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.peer_mtu_;
}
inline void PeerEntry::_internal_set_peer_mtu(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.peer_mtu_ = value;
}

// .proto.control_plane.v1.HopField hop_field = 4;
inline bool PeerEntry::has_hop_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hop_field_ != nullptr);
  return value;
}
inline void PeerEntry::clear_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.hop_field_ != nullptr) _impl_.hop_field_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::control_plane::v1::HopField& PeerEntry::_internal_hop_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::control_plane::v1::HopField* p = _impl_.hop_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::control_plane::v1::HopField&>(::proto::control_plane::v1::_HopField_default_instance_);
}
inline const ::proto::control_plane::v1::HopField& PeerEntry::hop_field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.PeerEntry.hop_field)
  return _internal_hop_field();
}
inline void PeerEntry::unsafe_arena_set_allocated_hop_field(::proto::control_plane::v1::HopField* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hop_field_);
  }
  _impl_.hop_field_ = reinterpret_cast<::proto::control_plane::v1::HopField*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.control_plane.v1.PeerEntry.hop_field)
}
inline ::proto::control_plane::v1::HopField* PeerEntry::release_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::HopField* released = _impl_.hop_field_;
  _impl_.hop_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::control_plane::v1::HopField* PeerEntry::unsafe_arena_release_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.PeerEntry.hop_field)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::control_plane::v1::HopField* temp = _impl_.hop_field_;
  _impl_.hop_field_ = nullptr;
  return temp;
}
inline ::proto::control_plane::v1::HopField* PeerEntry::_internal_mutable_hop_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hop_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::control_plane::v1::HopField>(GetArena());
    _impl_.hop_field_ = reinterpret_cast<::proto::control_plane::v1::HopField*>(p);
  }
  return _impl_.hop_field_;
}
inline ::proto::control_plane::v1::HopField* PeerEntry::mutable_hop_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::control_plane::v1::HopField* _msg = _internal_mutable_hop_field();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.PeerEntry.hop_field)
  return _msg;
}
inline void PeerEntry::set_allocated_hop_field(::proto::control_plane::v1::HopField* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::control_plane::v1::HopField*>(_impl_.hop_field_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::control_plane::v1::HopField*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hop_field_ = reinterpret_cast<::proto::control_plane::v1::HopField*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.PeerEntry.hop_field)
}

// -------------------------------------------------------------------

// HopField

// uint64 ingress = 1;
inline void HopField::clear_ingress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ingress_ = ::uint64_t{0u};
}
inline ::uint64_t HopField::ingress() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.HopField.ingress)
  return _internal_ingress();
}
inline void HopField::set_ingress(::uint64_t value) {
  _internal_set_ingress(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.HopField.ingress)
}
inline ::uint64_t HopField::_internal_ingress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ingress_;
}
inline void HopField::_internal_set_ingress(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ingress_ = value;
}

// uint64 egress = 2;
inline void HopField::clear_egress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.egress_ = ::uint64_t{0u};
}
inline ::uint64_t HopField::egress() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.HopField.egress)
  return _internal_egress();
}
inline void HopField::set_egress(::uint64_t value) {
  _internal_set_egress(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.HopField.egress)
}
inline ::uint64_t HopField::_internal_egress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.egress_;
}
inline void HopField::_internal_set_egress(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.egress_ = value;
}

// uint32 exp_time = 3;
inline void HopField::clear_exp_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_time_ = 0u;
}
inline ::uint32_t HopField::exp_time() const {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.HopField.exp_time)
  return _internal_exp_time();
}
inline void HopField::set_exp_time(::uint32_t value) {
  _internal_set_exp_time(value);
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.HopField.exp_time)
}
inline ::uint32_t HopField::_internal_exp_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_time_;
}
inline void HopField::_internal_set_exp_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.exp_time_ = value;
}

// bytes mac = 4;
inline void HopField::clear_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& HopField::mac() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.control_plane.v1.HopField.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HopField::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.control_plane.v1.HopField.mac)
}
inline std::string* HopField::mutable_mac() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:proto.control_plane.v1.HopField.mac)
  return _s;
}
inline const std::string& HopField::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void HopField::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArena());
}
inline std::string* HopField::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArena());
}
inline std::string* HopField::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.control_plane.v1.HopField.mac)
  return _impl_.mac_.Release();
}
inline void HopField::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.control_plane.v1.HopField.mac)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace control_plane
}  // namespace proto


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::proto::control_plane::v1::SegmentType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::proto::control_plane::v1::SegmentType>() {
  return ::proto::control_plane::v1::SegmentType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2fcontrol_5fplane_2fv1_2fseg_2eproto_2epb_2eh
